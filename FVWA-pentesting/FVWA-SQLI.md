## [ЗАДАНИЕ 5 - SQLI]
**SQLI (SQL Injection)** - это тип атаки на веб приложение, при котором злоумышленник может внедрить вредоносный код или изменить существующие запросы в приложении, которые могут привестит к нежелательным последствиям (обнаружение или модификация конфиденциальных данных, управление БД).

Уязвимсоть SQLI находится наиболее часто в веб приложениях, которые используют пользовательский ввод в SQL-запросах без должной проверки и экранирования.

---

Следующий фрагмент кода отвечает за процесс авторизации в веб приложении:
![97422c3f-3c99-4599-9e64-25c3231ba007](https://github.com/user-attachments/assets/4d16df90-3b7b-40f5-bc20-dac6514c073a)

Здесь используется файловая БД SQLite. При пользовательском вводе логина и пароля значения, передаются напрямую в запрос к БД бех их предварительной обработки.

Далее приведен обычный запрос от пользователя, когда он, в качестве имени и пароля вводит пару user:pass. В это время на бэкендк формируется строка запроса к БД, куда встраиваются вводимые параметры.
![51fecc3e-396d-4590-a39f-5d05759892ca](https://github.com/user-attachments/assets/c1ccfdd9-d83d-41f3-b986-f7eee45320c3)

Но что, если злоумышленник злоупотребит синтаксисом SQL и обманет приложение? Это становится возможным, поскольку нет никакой проверки и защиты.
##
В прошлом примере была запись, где были введены два параметра - логин и пароль. Но злоумышленнику не обязательно знать эту информацию, чтобы обойти форму авторизации.

Если в качестве логина он введет ''' or 1=1; -- -", а в качестве пароля любую последовательность символов, то в таком случае запрос будет выглядить следующим образом:
```
SELECT username,password FROM users WHERE username='' or 1=1;-- -' AND password='123';
```
Часть после -- - (символы комметария в mysql) будет отброшена, и запрос на самом деле будет выглядить так:
```
SELECT username,password FROM users WHERE username='' or 1=1;
```
Очевидно, что условие "WHERE username='' or 1=1" будет всегда истинным, так как один равно одному. И, следовательно, база данных в ответ на такой запрос вернёт все записи из таблицы users.
Такие образом, не зная логина и пароля, злоумышленник может обойти авторизацию в приложении путем эксплуатации SQL-инъекции.
##
### Последствия эксплуатации уязвимости SQL Injection могут быть серьезными:
- **Обход аутентификации:**
злоумышленник может использовать SQL Injection для обхода системы аутентификации и получения доступа к защищенным ресурсам или функциям.
- **Получение конфиденциальной информации:**
злоумышленник может использовать SQL Injection для извлечения конфиденциальных данных, таких как данные о пользователях, пароли, данные кредитных карт и другие чувствительные данные.
- **Уничтожение данных:**
злоумышленник может использовать SQL Injection для модификации запросов с целью удаления, изменения или изменения данных в базе данных.
- **Выполнение произвольного кода:**
с помощью SQL Injection злоумышленник может выполнить произвольный SQL-код на сервере, что может привести к выполнению нежелательных операций, компрометации данных или повреждению системы.
- **Отказ в обслуживании (DoS):** 
с помощью SQL Injection можно создать специально сформированные запросы, которые вызовут сильную нагрузку на сервер и приведут к отказу в его работе.
- **Компрометация системы:**
в некоторых случаях злоумышленники могут использовать SQL Injection для получения полного контроля над системой и запуска дополнительных атак или вредоносных действий на сервере (например, получение RCE через уязвимость SQL Injection).

---

Итак, чтобы пройти это задание в поле логина надо ввести: ' or 1=1 -- -
Нам покажет приветствие. Теперь необходимо распознать СУБД, с которой работает приложение. Синтаксис для дальнейшей эксплуатации будет разным для всех СУБД.
Для SQLite запрос будет следующим:
```
' unoin select sqlite_version(),null;-- -
```
и получаем версию СУБД.

Для извлечения flag_value из таблицы flag:
```
undefined
' union select flag_value,null from flag-- -
```
